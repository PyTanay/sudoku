[{"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\index.js":"1","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\App.js":"2","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\reportWebVitals.js":"3","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\Utility.jsx":"4","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\WholeGrid.jsx":"5","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\AllNumSel.jsx":"6","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\OneRow.jsx":"7","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\Solve.jsx":"8","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\NumberSelector.jsx":"9","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\SingleBox.jsx":"10","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\TimerBox.jsx":"11"},{"size":517,"mtime":1611147647139,"results":"12","hashOfConfig":"13"},{"size":3440,"mtime":1611948121504,"results":"14","hashOfConfig":"13"},{"size":375,"mtime":1611147647140,"results":"15","hashOfConfig":"13"},{"size":1013,"mtime":1611948527700,"results":"16","hashOfConfig":"13"},{"size":4185,"mtime":1611946768887,"results":"17","hashOfConfig":"13"},{"size":832,"mtime":1611948453489,"results":"18","hashOfConfig":"13"},{"size":629,"mtime":1611324810330,"results":"19","hashOfConfig":"13"},{"size":6454,"mtime":1611932233852,"results":"20","hashOfConfig":"13"},{"size":1226,"mtime":1611924657007,"results":"21","hashOfConfig":"13"},{"size":4546,"mtime":1611931719584,"results":"22","hashOfConfig":"13"},{"size":1020,"mtime":1611947315225,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"1mi9bpo",{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"26"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"26"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\index.js",[],["49","50"],"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\App.js",["51"],"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\reportWebVitals.js",[],"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\Utility.jsx",[],"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\WholeGrid.jsx",["52"],"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\AllNumSel.jsx",[],"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\OneRow.jsx",[],"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\Solve.jsx",["53","54"],"import React, { useContext,useEffect,useState } from \"react\";\r\nimport { FiCheckCircle } from \"react-icons/fi\";\r\nimport { AppContext } from \"../App\";\r\n\r\nfunction Solve() {\r\n  const { value, getCol, getBlock, getBlockAddress,solution,setSolution, setDisplayError } = useContext(AppContext);\r\n  const [solving, setSolving] = useState(false)\r\n  const [counter, setCounter] = useState(1)\r\n  const [solMatrix, setSolMatrix] = useState(Array.from({length: 9},()=> Array.from({length: 9}, () => Array.from(\"123456789\"))))\r\n\r\n  const solveSudoku =() => {\r\n    setSolving(true)\r\n    setSolution(methodA(value))\r\n  };\r\n  useEffect(() => {\r\n    setTimeout(()=>{\r\n      solveSudoku()\r\n    },200)\r\n  },[])\r\n  useEffect(() => {\r\n    if(isFinished(solution)===false && counter<20 && solving===true){\r\n      // console.log(solMatrix,\"Iteration\",counter)\r\n      setSolution(methodA(solution))\r\n      setCounter(counter+1)\r\n    }else if(isFinished(solution)===true){\r\n      console.log(\"Sudoku successfully solved\")\r\n      // console.log(solution)\r\n      setSolution(solution)\r\n      setSolving(false)\r\n      setCounter(1)\r\n    }else if(counter===20){\r\n      console.log(\"Maximum iteration reached, Could not solve the sudoku.\")\r\n      console.log(solution)\r\n      setSolving(false)\r\n      setCounter(1)\r\n    }else{\r\n      console.log(\"something's wrong\")\r\n      setSolving(false)\r\n      setCounter(1)\r\n    }\r\n  }, [solution])\r\n\r\n  const isFinished = (currentVal) => {\r\n    var currArr = [];\r\n    currentVal.forEach((row) => {\r\n      row.forEach((col) => currArr.push(col));\r\n    });\r\n    currArr = currArr.filter((elem) => elem === null);\r\n    return currArr.length === 0 ? true : false;\r\n  };\r\n  //there are two solution methods and in order to solve sudoku both method needs to be implemented mulltiple times\r\n  //methodA --> checks the cell against row column and blocks and figures which solutions are possible for the cell\r\n  //methodB --> checks the cell solutions based on the other for related blocks\r\n  const methodA =(startPoint) => {\r\n    var temp = JSON.parse(JSON.stringify(startPoint));\r\n    var tempSol = Array(9).fill([]);\r\n    // console.log(solMatrix)\r\n    solMatrix.forEach((row, rowIndex) => {\r\n      var tempSol2 = [];\r\n      row.forEach((col, colIndex) => {\r\n        if (value[rowIndex][colIndex] === null) {\r\n          var filtRow = temp[rowIndex].filter((elem) => elem !== null).filter(elem=>elem!==temp[rowIndex][colIndex]);\r\n          var filtColumn = getCol(temp, colIndex).filter((elem) => elem !== null).filter(elem=>elem!==temp[rowIndex][colIndex]);\r\n          var filtBlock = getBlock(temp, getBlockAddress([rowIndex, colIndex])).filter((elem) => elem !== null).filter(elem=>elem!==temp[rowIndex][colIndex]);\r\n          var tempCell = col.filter((elem) => !filtRow.includes(elem));\r\n          tempCell = tempCell.filter((elem) => !filtColumn.includes(elem));\r\n          tempCell = tempCell.filter((elem) => !filtBlock.includes(elem));\r\n        } else {\r\n          tempCell = [value[rowIndex][colIndex]];\r\n        }\r\n        tempSol2.push(JSON.parse(JSON.stringify(tempCell)));\r\n        if (tempCell.length === 1 && temp[rowIndex][colIndex] === null) {\r\n          temp[rowIndex][colIndex] = tempCell[0];\r\n        }\r\n      });\r\n      tempSol[rowIndex] = JSON.parse(JSON.stringify(tempSol2));\r\n    });\r\n    \r\n    tempSol.forEach((row, rowIndex) =>{\r\n      row.forEach((col, colIndex) => {\r\n        var crossRef = findUniqueFromMatrix(col, tempSol, rowIndex, colIndex);\r\n        if (crossRef !== null && temp[rowIndex][colIndex] === null) {\r\n          temp[rowIndex][colIndex] = crossRef;\r\n          tempSol[rowIndex][colIndex]=[crossRef]\r\n        }\r\n        // console.log(rowIndex,colIndex,findUniqueFromMatrix(col,tempSol,rowIndex,colIndex))\r\n      })\r\n    });\r\n    cleanUpSolMatrix(tempSol)\r\n    return temp;\r\n  };\r\n  const cleanUpSolMatrix=(matrix)=>{\r\n    var tempMatrix=JSON.parse(JSON.stringify(matrix));\r\n    tempMatrix.forEach((row,rowIndex)=>{\r\n      row.forEach((col,colIndex)=>{\r\n        // var col=JSON.parse(JSON.stringify(col))\r\n        const rowArr = tempMatrix[rowIndex];\r\n        const colArr = getCol(tempMatrix, colIndex);\r\n        const blockArr = getBlock(tempMatrix, getBlockAddress([rowIndex, colIndex]));\r\n        // console.log(\"Address\",rowIndex,colIndex)\r\n        col=findUniquePair(col,rowArr)\r\n        col=findUniquePair(col,colArr)\r\n        col=findUniquePair(col,blockArr)\r\n        tempMatrix[rowIndex][colIndex]=col\r\n      })\r\n    })\r\n    // console.log(tempMatrix.map(elem=>elem.map(elem1=>elem1.toString())))\r\n    setSolMatrix(tempMatrix)\r\n    // console.log(solMatrix.map(elem=>elem.map(elem1=>elem1.toString())))\r\n\r\n    // solMatrix=tempMatrix\r\n  }\r\n  const findUniquePair=(valArr,arr1)=>{\r\n    var tempArr=JSON.parse(JSON.stringify(valArr))\r\n    var temp=[]\r\n    arr1.forEach(elem=>{\r\n      if(elem.length===2 && arr1.filter(elem1=>elem1.toString()===elem.toString()).length===2){\r\n        if(elem.toString()!==tempArr.toString()){\r\n          if(!temp.includes(elem[0]) && !temp.includes(elem[1])){\r\n            temp.push(elem[0])\r\n            temp.push(elem[1])\r\n          }\r\n        }\r\n      }\r\n    })\r\n    // console.log(temp)\r\n    tempArr=tempArr.filter(elem2=>!temp.includes(elem2))\r\n    return tempArr\r\n  }\r\n  const findUniqueFromMatrix = (valArr, matrix, row, col) => {\r\n    var tempMatrix = JSON.parse(JSON.stringify(matrix));\r\n    const rowResult = findUniqueFromArr(valArr, tempMatrix[row]);\r\n    const colResult = findUniqueFromArr(valArr, getCol(tempMatrix, col));\r\n    const blockResult = findUniqueFromArr(valArr, getBlock(tempMatrix, getBlockAddress([row, col])));\r\n    // console.log(rowResult?rowResult: colResult ? colResult : blockResult ? blockResult : null,row,col)\r\n    return rowResult ? rowResult : colResult ? colResult : blockResult ? blockResult : null;\r\n  };\r\n  const findUniqueFromArr = (valArr, arr1) => {\r\n    var ret = JSON.parse(JSON.stringify(arr1));\r\n    var temp = [];\r\n    ret.forEach((elem) => elem.forEach((ele) => temp.push(ele)));\r\n    var uniqDigit = [];\r\n    valArr.forEach((elem) => temp.filter((e) => e === elem).length === 1 && uniqDigit.push(elem));\r\n    return uniqDigit.toString();\r\n  };\r\n  const checkSudoku=()=>{\r\n    setDisplayError(true)\r\n    setTimeout(()=>{\r\n      setDisplayError(false)\r\n    },2000)\r\n  }\r\n  return (\r\n    <button className=\"btn\" onClick={checkSudoku}>\r\n      <FiCheckCircle /> Check\r\n    </button>\r\n  );\r\n}\r\n\r\nexport default Solve;\r\n","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\NumberSelector.jsx",[],"C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\SingleBox.jsx",["55"],"import React, { useState, useContext, useEffect, useRef } from \"react\";\r\nimport { AppContext } from \"../App\";\r\nimport \"./singleBox.css\";\r\n\r\nfunction SingleBox(props) {\r\n  const { selected, setSelected, value, getCol, getBlock, getBlockAddress, initialValue, path, setPath, solution,displayError } = useContext(\r\n    AppContext\r\n  );\r\n  const [address] = useState([props.row, props.col]);\r\n  const [check, setCheck] = useState(displayError)\r\n  var classList = [\"singleBox\"];\r\n  const pervValueRef = useRef();\r\n  useEffect(() => {\r\n    pervValueRef.current = value;\r\n  });\r\n  useEffect(() => {\r\n      setCheck(displayError)\r\n  }, [displayError])\r\n  const prevValue = pervValueRef.current;\r\n  useEffect(() => {\r\n    if (prevValue !== undefined) {\r\n      const currVal = value[props.row][props.col];\r\n      const prevVal = prevValue[props.row][props.col];\r\n      if (currVal !== prevVal && initialValue[props.row][props.col] === null) {\r\n        const data = { row: props.row, col: props.col, currVal, prevVal };\r\n        const tempPath = JSON.parse(JSON.stringify(path));\r\n        tempPath.push(data);\r\n        setPath(tempPath);\r\n        // console.log(`Address ${props.row},${props.col} changed from ${prevVal} to ${currVal}`)\r\n      }\r\n    }\r\n  }, [value]);\r\n  //this is for original data - that can not be changed\r\n  if (initialValue.length > 0) {\r\n    if (initialValue[address[0]][address[1]] !== null) {\r\n      // console.log(initialValue[address[0]][address[1]],address)\r\n      classList.push(\"disabledBox\");\r\n    }\r\n  }\r\n\r\n  //this adds class to display selected number\r\n  if (selected.toString() === address.toString() && !classList.includes(\"selectedBox\")) {\r\n    classList.push(\"selectedBox\");\r\n  } else {\r\n    classList = classList.filter((elem) => elem !== \"selectedBox\");\r\n  }\r\n  //this adds class to display mistakes you have made compared to solution\r\n  if (check && value[address[0]][address[1]] !== solution[address[0]][address[1]] &&\r\n    value[address[0]][address[1]] !== null &&\r\n    !classList.includes(\"errorBox\") &&\r\n    !classList.includes(\"disabledBox\")) {\r\n    // console.log(\"Pushing error box\");\r\n    // classList=classList.filter(elem=>elem!==\"\")\r\n    classList.push(\"errorBox\");\r\n    // console.log(classList);\r\n  } else {\r\n    classList = classList.filter((elem) => elem !== \"errorBox\");\r\n  }\r\n\r\n  //this adds class to display similar cells\r\n  if (value[address[0]][address[1]] !== null && selected[0] !== undefined) {\r\n    if (value[address[0]][address[1]] === value[selected[0]][selected[1]] && address.toString() !== selected.toString()) {\r\n      classList.push(\"similarBox\");\r\n    } else {\r\n      classList = classList.filter((elem) => elem !== \"similarBox\");\r\n    }\r\n  }\r\n  //this is for validation and adds class to invalid cells\r\n  //row test\r\n  if (\r\n    selected[0] !== undefined &&\r\n    value[selected[0]][selected[1]] !== null &&\r\n    address[0] === selected[0] &&\r\n    address[1] !== selected[1]\r\n  ) {\r\n    if (\r\n      value[address[0]].filter((x) => x === value[selected[0]][selected[1]]).length > 1 &&\r\n      value[address[0]][address[1]] === value[selected[0]][selected[1]]\r\n    ) {\r\n      classList.push(\"dangerBox\");\r\n    } else {\r\n      classList = classList.filter((elem) => elem !== \"dangerBox\");\r\n    }\r\n  }\r\n  //column test\r\n  if (\r\n    selected[0] !== undefined &&\r\n    value[selected[0]][selected[1]] !== null &&\r\n    address[1] === selected[1] &&\r\n    address[0] !== selected[0]\r\n  ) {\r\n    if (\r\n      getCol(value, selected[1]).filter((x) => x === value[selected[0]][selected[1]]).length > 1 &&\r\n      value[address[0]][address[1]] === value[selected[0]][selected[1]]\r\n    ) {\r\n      classList.push(\"dangerBox\");\r\n    } else {\r\n      classList = classList.filter((elem) => elem !== \"dangerBox\");\r\n    }\r\n  }\r\n  //block test\r\n  if (\r\n    selected[0] !== undefined &&\r\n    value[selected[0]][selected[1]] !== null &&\r\n    address[0] !== selected[0] &&\r\n    getBlockAddress(address).toString() === getBlockAddress(selected).toString()\r\n  ) {\r\n    if (\r\n      getBlock(value, getBlockAddress(address)).filter((x) => x === value[address[0]][address[1]]).length > 1 &&\r\n      value[address[0]][address[1]] === value[selected[0]][selected[1]]\r\n    ) {\r\n      classList.push(\"dangerBox\");\r\n    } else {\r\n      classList = classList.filter((elem) => elem !== \"dangerBox\");\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div onClick={() => setSelected(address)} className={classList.join(\" \")}>\r\n      <div className=\"text1\">{value[address[0]][address[1]]}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default SingleBox;\r\n","C:\\Users\\tanay\\PycharmProjects\\learning_javascript\\sudoku\\src\\components\\TimerBox.jsx",[],{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","replacedBy":"59"},{"ruleId":"60","severity":1,"message":"61","line":9,"column":8,"nodeType":"62","messageId":"63","endLine":9,"endColumn":15},{"ruleId":"64","severity":1,"message":"65","line":82,"column":7,"nodeType":"66","endLine":82,"endColumn":17,"suggestions":"67"},{"ruleId":"64","severity":1,"message":"68","line":19,"column":5,"nodeType":"66","endLine":19,"endColumn":7,"suggestions":"69"},{"ruleId":"64","severity":1,"message":"70","line":41,"column":6,"nodeType":"66","endLine":41,"endColumn":16,"suggestions":"71"},{"ruleId":"64","severity":1,"message":"72","line":32,"column":6,"nodeType":"66","endLine":32,"endColumn":13,"suggestions":"73"},"no-native-reassign",["74"],"no-negated-in-lhs",["75"],"no-unused-vars","'Utility' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'initialValue', 'setSelected', 'setValue', and 'value'. Either include them or remove the dependency array.","ArrayExpression",["76"],"React Hook useEffect has a missing dependency: 'solveSudoku'. Either include it or remove the dependency array.",["77"],"React Hook useEffect has missing dependencies: 'counter', 'methodA', 'setSolution', and 'solving'. Either include them or remove the dependency array. You can also do a functional update 'setCounter(c => ...)' if you only need 'counter' in the 'setCounter' call.",["78"],"React Hook useEffect has missing dependencies: 'initialValue', 'path', 'prevValue', 'props.col', 'props.row', and 'setPath'. Either include them or remove the dependency array.",["79"],"no-global-assign","no-unsafe-negation",{"desc":"80","fix":"81"},{"desc":"82","fix":"83"},{"desc":"84","fix":"85"},{"desc":"86","fix":"87"},"Update the dependencies array to be: [initialValue, selected, setSelected, setValue, value]",{"range":"88","text":"89"},"Update the dependencies array to be: [solveSudoku]",{"range":"90","text":"91"},"Update the dependencies array to be: [counter, methodA, setSolution, solution, solving]",{"range":"92","text":"93"},"Update the dependencies array to be: [initialValue, path, prevValue, props.col, props.row, setPath, value]",{"range":"94","text":"95"},[3863,3873],"[initialValue, selected, setSelected, setValue, value]",[688,690],"[solveSudoku]",[1396,1406],"[counter, methodA, setSolution, solution, solving]",[1248,1255],"[initialValue, path, prevValue, props.col, props.row, setPath, value]"]